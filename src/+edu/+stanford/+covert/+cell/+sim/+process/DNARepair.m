%DNA Repair
%
% @wholeCellModelID Process_DNARepair
% @name             DNA Repair
% @description
%   Biology
%   =====================================================================
%   Simulates repair of a spectrum of DNA lesions by the direct damage
%   repair (DDR), base excision (BER), nucleotide excision (NER), and
%   homologous recombination (HR) DNA repair pathways. The table below
%   summarizes the pathways of DNA repair modelled here.
%
%      Damage                   Repair Pathway
%      ======                   ==============
%      Abasic site              BER
%      Damaged base             BER, GG-NER
%      Intrastrand crosslink    GG-NER
%      Single strand break      DDR
%      Double strand break      HR-DSBR
%
%   This process also simulates DNA damage recognition by the DNA integrity
%   scanning protein DisA (MG_105).
%
%   Direct Damage Reversal (DDR)
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   The only direct damage repair homolog identified in M. genitalium is
%   ligase ligA (MG_254). ligA is capable of repairing single strand
%   breaks by a NAD-dependent mechanism:
%
%         base    O   base    O           base    O   base    O
%          |     ||    |     ||            |      ||   |     ||
%   ...-O-sugar-O-P-O-sugar-O-P-O-  +  HO-sugar-O-P-O-sugar-O-P...  + NAD
%                 |           |                   |           |
%                 O           O                   O           O
%
%                                    ||
%                                    ||
%                                    V
%
%
%         base    O    base   O   base    O   base   O
%          |     ||    |     ||    |     ||    |    ||
%   ...-O-sugar-O-P-O-sugar-O-P-O-sugar-O-P-O-sugar-O-P...  + AMP + NMN + H
%                 |           |           |           |
%                 O           O           O           O
%
%
%   Base Excision Repair (BER)
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   Repairs specific spontaneously and endogenously produced DNA damaged
%   including base modifications, abasic sites, and single strand breaks
%   by the following mechanism:
%   1. Base excision by Fpg (MG_498) or Ung (MG_097) glycosylase
%
%         base    O                 OH      O
%          |     ||                  |     ||
%      -O-sugar-O-P... + H2O ==> -O-sugar-O-P  +  base
%                 |                         |
%                 O                         O
%
%   2. a. i.  3'-AP lyase Fpg (MG_498)
%         ii. 5'-AP endonuclease Nfo (MG_235)
%      b. i.  5'-deoxyribosephosphodiesterase Nfo (MG_235)
%         ii. 3'-(deoxyribose-5'-phosphate) lyase dnaN (MG_001)
%   3. 5'-3' Polymerization by dnaN (MG_001)
%   4. Ligation by ligA (MG_254). See DDR section for details.
%   5. Catabolism and export of damaged nucleobases and nucleosides by
%      metabolic process.
%
%   Flap endonuclease fen1 homologs have not been identified in M.
%   genitalium; MG_262 is a weak fen1 homolog, but is more strongly
%   homologous to polI exonucleases. Consequently, we do not model flap
%   base excision repair.
%
%   Global Genomic (GGR) Nucleotide Excision Repair (NER)
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   NER recognizes bulky distortions in the shape of the DNA helix caused
%   by damaged bases and cross links caused by NO and UV light, and uses
%   endonucleases with lower specificity than that of BER. Consequently,
%   NER has broader repair capability than base excision repair. Here we
%   model only global genomic NER. In some bacteria such as E. coli DNA
%   damage is sensed by RNA polymerase and coupled to the NER machinery by
%   the transcription-repair coupling factor mfd.
%
%   1. UvrABC (MG_073, MG_206, MG_421) cleaves DNA 3' and 5' to lesion
%   2. Helicase PcrA (MG_244) excises cleaved DNA
%   3. Cleavage excised oligonucleotide (12-13 nts) by MgpA (MG_190)
%   4. 5'-3' Polymerization by dnaN (MG_001)
%   5. Ligation by ligA (MG_254). See DDR section for details.
%   6. Catabolism and export of damaged nucleobases and nucleosides by
%      metabolic process.
%
%   Note steps (3) and (4-5) occur in parallel. NER removes 2.7 x 10^3
%   excison products per cell per minute.
%
%   Homologous Recombination (HR) Double Strand Break Repair (DSBR)
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   HR repairs double strand breaks caused by ionizing radiation and
%   stalled replicaton forks. HR also repairs strand gaps which can be
%   generated by the interaction of replication forks with unrepaired
%   lesions. M. genitalium has a very reduced complement of recombination
%   repair proteins. Normally recombination repair involves the following
%   steps:
%   1. Initiation: 5'-3' exonuclease removes dNMPs from 5' ends of strands
%      leaving 3' overhangs. Daley and Wilson have shown homologous
%      recombination is most efficient with overhangs of at least 8 bases
%      [6]. No tradiational initiation gene has been identified in M.
%      genitalium. 5'-3' resection could be carried out by pcrA (MG_244)
%      or polI-like (MG_262). Here we model pcrA as the NER helicase, and
%      therefore choose to model polI-like as the HR initiator.
%   2. Strand exchange: One of the damaged 3' overhang invades the
%      undamaged homologous chromosome, forming a holliday junction.
%      Catalyzed by recA (MG_339)
%   3. 5'-3' Polymerization by dnaN (MG_001)
%   4. 2 ligations by ligA (MG_254). See DDR section for details.
%   5. Second strand exchange: The second damaged 3' overhang invades the
%      undamaged homologous chromosome, forming a second holliday
%      junction. Also catalyzed by recA (MG_339)
%   6. Holliday junction migration: ruvAB (MG_358, MG_359) widens distance
%      between the two strand cross over points by moving holliday
%      junctions to preferred sequence 5'-(A/T)TT?(G/C)-3' [PUB_0532].
%   7. Resolution: recU (MG_352) dimer nicks DNA at cross over points
%      creating four single strand breaks
%   8. 4 ligations by ligA (MG_254). See DDR section for details.
%   9. Catabolism and export of damaged nucleobases and nucleosides by
%      metabolic process.
%
%   Additionally, homologous recombination is believed to be critical
%   for antigenic variation in M. genitalium (Sluijter et al).
%
%   DNA integrity scanning protein DisA
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   In B. subtilis DisA recognizes strand breaks, base damage,
%   and cross links (possibly through ssDNA, Holliday junctions, or stalled
%   replication forks that are generated during recombination repair of
%   these lesions), binds damaged DNA, and via an unknown mechanism delays
%   sporulation. DisA has weak, non-specific DNA binding. In addition DisA
%   has diadenylate cyclization (produces c-di-AMP from 2 ATPs) activity
%   which is abolished when bound to branched DNA such as Holliday
%   junctions. c-di-AMP has been speculated as the second messenger which
%   couples DisA damage recognition to regulation of the transcriptional
%   regulator Spo0A, and delayed sporulation. The rest of the B. subtilis
%   signaling system (spo0A, kinA, kinE) is not present in M. genitalium.
%
%   DNA Restriction/Modification
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   Organisms employ a restriction/modification systems to distinguish
%   self from foreign DNA. These systems methylate hemi-methylated DNA and
%   cleave unmethylated DNA. The systems maintains self DNA in the fully
%   methylated state so that it can be distinguished from foreign
%   DNA (which will be unmethylated) on methylation status.
%
%   M. genitalium contains a reduced restriction/modification system
%   consisting of the EcoD type I DNA recognition subunit (MG_438) and the
%   MunI type II methylase (MG_184). M. genitalium does not contain a
%   type III R/M system.
%
%   EcoD is the DNA binding domain of a multimetric methylation and
%   restriction complex. Type I R/M systems typically have structure R2M2S
%   or M2S. EcoD recognizes the sequence 5'-TCARTTC-3'. The other subunits
%   methylate the N(7) position of A-3, producing N(7)-methyladenine or
%   cleavage DNA at this position. M. genitalium contains only the DNA
%   recognition subunit. 
%
%   MunI methylase (MG_184) methylates the N(6) position of A-3 in the
%   sequence 5'-CAATTG-3', producing N(6)-methyladenine. M. genitalium
%   does not contain a MunI endonuclease. Type II R/M systems have been
%   found as monomers, dimers, and trimers.
%
%   DNA repair mechanisms not present in M. genitalium
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   - Transcription-coupled NER (TC-NER)
%     M. genitalium does not have a transcription-repair coupling factor
%     mfd homolog.
%   - Additional eukaryotic homologous recombination (HR) pathways
%     - Synthesis-dependent strand annealing (SDSA)
%     - Single-strand annealing (SSA)
%     - Break-induced replication (BIR)
%   - Non-homologous end joining (NHEJ)
%     M. genitalium does not have a dedicated NHEJ DNA ligase ligD or a
%     DNA-end-binding protein Ku.
%   - Mismatch Repair
%   - SOS Response
%
%   Metabolism of damaged nucleo-bases, -sides, and -tides
%   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%   No gene has been identified which cleaves DNA oligonucleotides;
%   possible genes include pcrA (MG_244), mgpA (MG_190), and polI-like
%   (MG_262). Here we model pcrA as the NER helicase and polI-like as the
%   HR resection enzyme, leaving mgpA without an assigned function.
%   Therefore we choose to model mgpA as capable of cleaving
%   oligonucleotides released by NER into single nucleotides.
%
%   Nucleotides released by polI-like or mgpA are returned to the
%   cytoplasmic free pool, and are available to the metabolism process.
%   Damaged nucleotides are degraded to nucleosides and are exported by
%   the metabolism process. Damaged nucleobases are also exported by the
%   metabolism process.
%
%   Knowledge Base
%   =====================================================================
%   As of 8/12/2010 the M. genitalium knowledge contained the stochiometry
%   and kinetics of 33 DNA repair reactions involving 16 enzymes. These
%   reactions were compiled from several sources.
%
%      Reaction Type                          Reactions
%      ========================               ==========
%      base excision repair	                   4
%      base excision repair, base excision	   6
%      DNA catabolism                          4
%      DNA ligation                            1
%      DNA polymerization                      4
%      DNA restriction/modification	           4
%      homologous recombination	               7
%      nucleotide excision repair	           2
%      second messenger generation	           1
%
%   Representation
%   =====================================================================
%   8 properties are used to keep track of the damage state of DNA. These
%   properties are owned by the DNA damage process, and are copied locally at
%   each time step. The first  dimension of each has length equal to that of
%   the chromosome.
%   - occupiedDNA               enumeration   proteins bound to DNA
%   - gapSites                  true/false    sugar gaps
%   - abasicSites               true/false    abasic sites
%   - damagedSugarPhosphates    enumeration   damaged sugar phosphates
%   - damagedBases              enumeration   damaged bases
%   - intrastrandCrossLinks     true/false    intrastand cross link
%   - strandBreaks              true/false    strand break (missing sugar-phosphate bond)
%   - hollidayJunctions         true/false    holliday junction
%
%   substrates represents the amounts of free metabolites. initializeConstants
%   synchronizes the substrates of this process with that of the DNA damage
%   process to make it easy for these processes to communicate. That is
%   initializeConstants sets the substrates of both processes equal to the union
%   of the two, are orders the substrates the same in both processes. Thus
%   substrate indices defined in process are valid on properties received from
%   the other process, and it is unecessary to remap properties in
%   copyFromState.
%
%   enzymes represents the amount of DNA repair enzymes.
%
%   Rather than using reactionStoichiometryMatrix directly this process
%   factors the reactionStoichiometryMatrix into two parts:
%   - reactionSmallMoleculeStoichiometryMatrix: the stochiometry of free
%     metabolites in repair reactions
%   - reactionDNAStoichiometryMatrix: the stoichiometry of DNA bases in
%     repair reactions
%
%   In addition, rather than using reactionModificationReaction to
%   represent the macromolecule affected by each reaction we use
%   reactionDNABase to represent the DNA base affected by each repair reaction.
%
%   reactionCatalysisMatrix represents the enzymes which catalyze each repair
%   reaction. enzymeBounds represents the backward and forward enzyme rate
%   constant of each repair reaction.
%
%   Several additional properties represent more detailed information
%   about the specific action of each enzyme.
%
%   Simulation
%   =====================================================================
%   The simulation is implemented as six subfunctions which are called in a
%   random order from evolveState:
%   - base excision repair
%   - nucleotide excision repair
%   - homologous recombination double strand break repair
%   - polymerization/ligation
%   - DisA damage recognition, and
%   - restriction/modification
%
%   Each subfunction carries out some variation of the algorithm:
%   1. Identify chromosomes sites that are substrates for the repair system
%   2. Eliminate sites that neighbor damage, or which are occupied by proteins
%      (other than the DNA damage scanning protein DisA).
%   3. Compute maximum number of repair reactions that can occur based on
%      metabolite and enzyme availability and kinetics.
%   4. Randomly select among chromosome sites
%   5. Update state of DNA. Update metabolites.
%   6. Free any DisA that was previously bound to the repaired site.
%
%   References
%   =====================================================================
%   1. B.A. Sokhansanj, G.R. Rodrigue, J.P. Fitch and D.M. Wilson III
%      (2002). A quantitative model of human DNA base excision repair: I.
%      Mechanistic insights. Nuc Acids Res. 30(8): 1817-25. [PUB_0488]
%   2. Sokhansanj BA, Wilson DM 3rd (2004). Oxidative DNA damage
%      background estimated by a system model of base excision repair.
%      Free Radic Biol Med. 37(3): 422-7. [PUB_0487]
%   3. Politi A, Moné MJ, Houtsmuller AB, Hoogstraten D, Vermeulen W,
%      Heinrich R, van Driel R (2005). Mathematical modeling of nucleotide
%      excision repair reveals efficiency of sequential assembly
%      strategies. Mol Cell. 19(5): 679-90. [PUB_0514]
%   4. Alain Blanchard, Glenn Browning (2005). Mycoplasmas: molecular
%      biology, pathogenicity and strategies for control. CRC Press.
%   5. Carvalho FM, Fonseca MM, Batistuzzo De Medeiros S, Scortecci KC,
%      Blaha CA, Agnez-Lima LF (2005). DNA repair in reduced genome: The
%      Mycoplasma model. Gene. 360(2): 111-9.
%   6. James M. Daley and Thomas E. Wilson (2005). Rejoining of DNA
%      Double-Strand Breaks as a Function of Overhang Length. Mol Cell
%      Biol. 25(3): 896-906.
%   7. Reardon JT, Sancar A (2005). Nucleotide Excision Repair. Prog
%      Nucleic Acid Res Mol Biol. 79: 183-235. [PUB_0084]
%   8. Marcelo Brocchi, Ana Tereza Ribeiro de Vasconcelos, and Arnaldo Zaha
%      (2007). Restriction-modification systems in Mycoplasma spp. Genet.
%      Mol. Biol. 30: 1. [PUB_0652]
%   9. Wilson GG, Murray NE (1991). Restriction and modification systems.
%      Annu Rev Genet. 25: 585-627. [PUB_0653]
%  10. Romling U (2008). Great Times for Small Molecules: c-di-AMP, a
%      Second Messenger Candidate in Bacteria and Archaea. Sci Signal.
%      1(33):39. [PUB_0195]
%  11. Erik Boye (2006). DisA, a Busy Bee That Monitors Chromosome
%      Integrity. Cell. 125(4):641-643. [PUB_0511]
%  12. Witte G, Hartung S, Büttner K, Hopfner KP (2008). Structural.
%      Biochemistry of a Bacterial Checkpoint Protein Reveals Diadenylate
%      Cyclase Activity Regulated by DNA Recombination Intermediates. Mol
%      Cell. 30(2):167-78. [PUB_0512]
%  13. Bejerano-Sagie M, Oppenheimer-Shaanan Y, Berlatzky I, Rouvinski A,
%      Meyerovich M, Ben-Yehuda S (2006). A checkpoint protein that scans
%      the chromosome for damage at the start of sporulation in Bacillus
%      subtilis. Cell. 125(4):679-90. [PUB_0513]
%  14. Murray NE (2000). Type I restriction systems: sophisticated
%      molecular machines (a legacy of Bertani and Weigle). Microbiol Mol
%      Biol Rev. 64(2):412-34. [PUB_0542]
%  15. Cline SD, Hanawalt PC (2003). Who's on first in the cellular
%      response to DNA damage? Nat Rev Mol Cell Biol. 4(5):361-72.
%      [PUB_0780]
%  16. Sluijter M, Kaptein E, Spuesens EB, Hoogenboezem T, Hartwig NG, Van 
%      Rossum AM, Vink C (2010). The Mycoplasma genitalium MG352-encoded protein 
%      is a Holliday junction resolvase that has a non-functional orthologue in 
%      Mycoplasma pneumoniae. Mol Microbiol. 77(5): 1261-77. [PUB_0797].
%
% Author: Jonathan Karr, jkarr@stanford.edu
% Affilitation: Covert Lab, Department of Bioengineering, Stanford University
% Last updated: 5/3/2010
classdef  DNARepair < edu.stanford.covert.cell.sim.ReactionProcess & edu.stanford.covert.cell.sim.ChromosomeProcessAspect
    %property annotations
    properties (Constant)
        optionNames__              = {}; %names of option properties        
        fixedConstantNames__       = {   %names of fixed constant properties
            'HR_PolA_ResectionLength';
            'HR_RecA_Spacing';
            'HR_RuvAB_JunctionMigrationHop';
            'HR_RecU_CleavageSequence';
            'HR_RecU_CleavagePosition';
            'NER_UvrABC_IncisionMargin3';
            'NER_UvrABC_IncisionMargin5';
            'NER_PcrA_StepSize';
            'hollidayJunctionResolutionSites';
            'RM_EcoD_RecognitionSequence';
            'RM_EcoD_RecognitionSites';
            'RM_EcoD_MethylationPosition';
            'RM_EcoD_RestrictionPosition';
            'RM_MunI_RecognitionSequence';
            'RM_MunI_RecognitionSites';
            'RM_MunI_MethylationPosition';
            'RM_MunI_RestrictionPosition';
            'RM_MunI_MethylatedPositions';
            'RM_MunI_RestrictionPositions';
            'reactionSmallMoleculeStoichiometryMatrix';
            'reactionDNAStoichiometryMatrix';
            'reactionDNABase';
			}
        fittedConstantNames__      = {}; %names of fitted constant properties
        localStateNames__          = {}; %names of simulation state properties redundant with timecourses in this or other processes or the simulation
    end

    %IDs, names, and local indices
    properties
        substrateIndexs_water                       %index within substrates of water
        substrateIndexs_hydrogen                    %index within substrates of hydrogen
        substrateIndexs_DR5P                        %index within substrates of deoxyribose-5-phosphate
        substrateIndexs_dRibose5P_dRibose5P         %index within substrates of (deoxyribose-5-phosphate)-(deoxyribose-5-phosphate)
        substrateIndexs_NAD                         %index within substrates of NAD
        substrateIndexs_AMP                         %index within substrates of AMP
        substrateIndexs_NMN                         %index within substrates of NMN
        substrateIndexs_PPI                         %index within substrates of diphosphate
        substrateIndexs_m6AD                        %index within substrates of 6-methyladenine
        substrateIndexs_undamagedNucleobases        %index within substrates of undamaged nucleobases
        substrateIndexs_damagedNucleobases          %index within substrates of damaged nucleobases
        substrateIndexs_damagedNucleosides          %index within substrates of damaged deoxyribonucleosides
        substrateIndexs_damagedDNMPs                %index within substrates of damaged dNMPs
        substrateIndexs_dNMPs                       %index within substrates of dNMPs
        substrateIndexs_dNTPs                       %index within substrates of dNTPs
        substrateIndexs_dNpdNps                     %index within substrates of (dNTP-dNTP)s

        enzymeIndexs_formamidopyrimidineGlycosylase %index within enzymes of formamidopyrimidine glycosylase
        enzymeIndexs_uracilGlycosylase              %index within enzymes of uracil glycosylase
        enzymeIndexs_apurinicEndonuclease           %index within enzymes of apurinic endonuclease
        enzymeIndexs_incisionComplex                %index within enzymes of incision complex
        enzymeIndexs_helicase35                     %index within enzymes of 3'->5' helicase
        enzymeIndexs_recombinationStrandExchange    %index within enzymes of recombination strand exchange
        enzymeIndexs_hollidayJunctionEndonuclease   %index within enzymes of holliday junction endonuclease
        enzymeIndexs_hollidayJunctionHelicase       %index within enzymes of holliday junction helicase
        enzymeIndexs_exonuclease53                  %index within enzymes of 5'->3' exonuclease
        enzymeIndexs_polymerase                     %index within enzymes of polymerase
        enzymeIndexs_ligase                         %index within enzymes of ligase
        enzymeIndexs_phosphoesterase                %index within enzymes of phosphoesterase
        enzymeIndexs_DisA                           %index within enzymes of DisA
        enzymeIndexs_RM_typeI                       %index within enzymes of Restriction/Modification typeI
        enzymeIndexs_RM_typeII                      %index within enzymes of Restriction/Modification typeII
        enzymeIndexs_BER_baseExcision               %index within enzymes of BER base Excision

        reactionIndexs_BER                          %index within reactions of BER
        reactionIndexs_BER_baseexcision             %index within reactions of BER base excision
        reactionIndexs_BER_aplyase                  %index within reactions of BER aplyase
        reactionIndexs_BER_drpesterase              %index within reactions of BER deoxyribosose-5'-phosphate esterase
        reactionIndexs_BER_apendonuclease           %index within reactions of BER AP endonuclease
        reactionIndexs_BER_dr5plyase                %index within reactions of BER deoxyribosose-5'-phosphate lyase
        reactionIndexs_NER                          %index within reactions of NER
        reactionIndexs_NER_incision                 %index within reactions of NER incision
        reactionIndexs_NER_excision                 %index within reactions of NER excision
        reactionIndexs_HR_dsbr                      %index within reactions of HR double strand break repair
        reactionIndexs_HR_DNAResection              %index within reactions of HR DNA resection
        reactionIndexs_HR_strandExchange            %index within reactions of HR strand exchange
        reactionIndexs_HR_junctionMigration         %index within reactions of HR junction migration
        reactionIndexs_HR_junctionResolution        %index within reactions of HR junction resolution
        reactionIndexs_ligation                     %index within reactions of ligation
        reactionIndexs_polymerization               %index within reactions of polymerization
        reactionIndexs_DNACleavage                  %index within reactions of DNA processive cleavage
        reactionIndexs_RM                           %index within reactions of Restriction/Modification reactions
        reactionIndexs_RM_EcoD_Methylation          %index within reactions of Restriction/Modification EcoD methylation
        reactionIndexs_RM_EcoD_Restriction          %index within reactions of Restriction/Modification EcoD restriction
        reactionIndexs_RM_MunI_Methylation          %index within reactions of Restriction/Modification MunI methylation
        reactionIndexs_RM_MunI_Restriction          %index within reactions of Restriction/Modification MunI restriction
    end
    
    %fixed biological constants
    properties        
        HR_PolA_ResectionLength                     %number of bases PolA resect DNA ends            8               b [PUB_0526]
        HR_RecA_Spacing                             %spacing between RecA molecule                   3               b [PUB_0082]
        HR_RuvAB_JunctionMigrationHop               %RuvAB junction migration hop                    2.2             b [PUB_0538]
        HR_RecU_CleavageSequence                    %RecU cleavage sequence                          WTTS              [PUB_0538]
        HR_RecU_CleavagePosition                    %RecU cleavage position within sequence          3                 [PUB_0538]
        
        NER_UvrABC_IncisionMargin3                  %3' distance between damage and UvrABC cleavage  4               b [PUB_0461]
        NER_UvrABC_IncisionMargin5                  %5' distance between damage and UvrABC cleavage  7               b [PUB_0461]
        NER_PcrA_StepSize                           %PcrA step size                                  1               b [PUB_0516]
        
        hollidayJunctionResolutionSites             %(no. sites) x 2 vector indicating positions of holliday junction resolution sites; first col - position; second col - strand        
        
        RM_EcoD_RecognitionSequence                 %EcoD recognition sequence                       TTANNNNNNNGTCY    [PUB_0542]
        RM_EcoD_RecognitionSites                    %(no. sites) x 2 vector indicating positions of restriction/modification methylation sites; first col - position; second col - strand
        RM_EcoD_MethylationPosition                 %EcoD methylation position within sequence       3                 [PUB_0542]
        RM_EcoD_RestrictionPosition                 %EcoD restriction position within sequence       []                [PUB_0542]        
        
        RM_MunI_RecognitionSequence                 %MunI recognition sequence                       CAATG             [PUB_0096]
        RM_MunI_RecognitionSites                    %(no. sites) x 2 vector indicating positions of restriction/modification methylation sites; first col - position; second col - strand
        RM_MunI_MethylationPosition                 %MunI methylation position within sequence       3                 [PUB_0096]
        RM_MunI_RestrictionPosition                 %MunI restriction position within sequence       1                 [PUB_0544]        
        RM_MunI_MethylatedPositions                 %columns within RM_MunI_RecognitionSites that represent methylation positions
        RM_MunI_RestrictionPositions                %columns within RM_MunI_RecognitionSites that represent cleaved phosphodiester bonds
               
        reactionSmallMoleculeStoichiometryMatrix    %stoichiometry of free metabolites in chemical reactions (substrates X reactions)
        reactionDNAStoichiometryMatrix              %stoichiometry of DNA bases in chemical reactions (substrates X reactions)
        reactionDNABase                             %substrate indices of DNA bases involved in each reaction (reactions X 1)        
    end

    %constructor
    methods
        function this = DNARepair(wholeCellModelID, name)
            this = this@edu.stanford.covert.cell.sim.ReactionProcess(wholeCellModelID, name);
        end
    end

    %communication between process/simulation
    methods
        %set references to state objects
        function storeObjectReferences(this, simulation)
            this.storeObjectReferences@edu.stanford.covert.cell.sim.Process(simulation);
            this.storeObjectReferences@edu.stanford.covert.cell.sim.ChromosomeProcessAspect(simulation);
        end
        
        %initialize constants
        function initializeConstants(this, knowledgeBase, simulation, varargin)
            %% call super class method to get reactions, substrates, and enzymes
            this.initializeConstants@edu.stanford.covert.cell.sim.ReactionProcess(knowledgeBase, simulation, varargin{:});
            this.initializeConstants@edu.stanford.covert.cell.sim.ChromosomeProcessAspect(knowledgeBase, simulation, varargin{:});

            %% additional substrates
            additionalSubstrates = findobj(knowledgeBase.metabolites,...
                'category', 'modified nucleobase',                        '-or',...
                'category', 'modified deoxyribonucleoside',               '-or',...
                'category', 'modified deoxyribonucleotide monophosphate', '-or',...
                'wholeCellModelID','URA',                                 '-or',...
                'wholeCellModelID','URI');
            substrateWholeCellModelIDs = unique([
                this.substrateWholeCellModelIDs;
                {additionalSubstrates.wholeCellModelID}';
                'AD'; 'CSN'; 'GN'; 'THY']);
            tfs = ismember(simulation.state('Metabolite').wholeCellModelIDs, substrateWholeCellModelIDs);
            if sum(tfs) ~= numel(substrateWholeCellModelIDs)
                throw(MException('DNARepair:error', 'Substrates must all be metabolites'));
            end
            substrateWholeCellModelIDs = simulation.state('Metabolite').wholeCellModelIDs(tfs);
            this.initializeConstants_overrideSubstrates(substrateWholeCellModelIDs);
            
            %% additional enzymes
            enzymeWholeCellModelIDs = unique([this.enzymeWholeCellModelIDs; 'MG_105_OCTAMER']);
            this.initializeConstants_overrideEnzymes(enzymeWholeCellModelIDs);

            %% parameters
            %knowledge base parameter class holds string values as cell arrays
            this.HR_RecU_CleavageSequence    = this.HR_RecU_CleavageSequence{1};
            this.RM_EcoD_RecognitionSequence = this.RM_EcoD_RecognitionSequence{1};
            this.RM_MunI_RecognitionSequence = this.RM_MunI_RecognitionSequence{1};

            %% substrate indices
            this.substrateIndexs_water                = this.substrateIndexs({'H2O'});
            this.substrateIndexs_hydrogen             = this.substrateIndexs({'H'});
            this.substrateIndexs_DR5P                 = this.substrateIndexs({'DR5P'});
            this.substrateIndexs_dRibose5P_dRibose5P  = this.substrateIndexs({'dRibose5P_dRibose5P'});
            this.substrateIndexs_NAD                  = this.substrateIndexs({'NAD'});
            this.substrateIndexs_AMP                  = this.substrateIndexs({'AMP'});
            this.substrateIndexs_NMN                  = this.substrateIndexs({'NMN'});
            this.substrateIndexs_PPI                  = this.substrateIndexs({'PPI'});
            this.substrateIndexs_m6AD                 = this.substrateIndexs({'m6AD'});
            this.substrateIndexs_undamagedNucleobases = this.substrateIndexs({'AD';'CSN';'GN';'THY'});
            this.substrateIndexs_damagedNucleobases   = this.substrateMetaboliteLocalIndexs(...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).category},'modified nucleobase') | ...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).wholeCellModelID},'URA'));
            this.substrateIndexs_damagedNucleosides = this.substrateMetaboliteLocalIndexs(...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).category},'modified deoxyribonucleoside') | ...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).wholeCellModelID},'URI'));
            this.substrateIndexs_damagedDNMPs = this.substrateMetaboliteLocalIndexs(...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).category},'modified deoxyribonucleotide monophosphate') | ...
                strcmp({knowledgeBase.metabolites(this.substrateMetaboliteGlobalIndexs).wholeCellModelID},'DUMP'));
            this.substrateIndexs_dNMPs                = this.substrateIndexs({'DAMP';'DCMP';'DGMP';'DTMP'});
            this.substrateIndexs_dNTPs                = this.substrateIndexs({'DATP';'DCTP';'DGTP';'DTTP'});
            this.substrateIndexs_dNpdNps              = this.substrateIndexs({'dApdAp';'dCpdCp';'dGpdGp';'dTpdTp'});

            %% enzyme indices
            this.enzymeIndexs_BER_baseExcision               = this.enzymeIndexs({'MG_097_MONOMER';'MG_498_MONOMER'});
            this.enzymeIndexs_formamidopyrimidineGlycosylase = this.enzymeIndexs({'MG_498_MONOMER'});          %BER  fpg          formamidopyrimidine-DNA glycosylase
            this.enzymeIndexs_uracilGlycosylase              = this.enzymeIndexs({'MG_097_MONOMER'});          %BER  ung          uracil-DNA glycosylase, putative
            this.enzymeIndexs_apurinicEndonuclease           = this.enzymeIndexs({'MG_235_MONOMER'});          %BER  nfo          apurinic endonuclease
            this.enzymeIndexs_incisionComplex                = this.enzymeIndexs({'MG_073_206_421_TETRAMER'}); %NER  uvrABC       DNA incision complex
            this.enzymeIndexs_helicase35                     = this.enzymeIndexs({'MG_244_DIMER'});            %NER  pcrA         3'-5' helicase
            this.enzymeIndexs_recombinationStrandExchange    = this.enzymeIndexs({'MG_339_MONOMER'});          %HR   recA         recombination protein, strand exchange
            this.enzymeIndexs_hollidayJunctionEndonuclease   = this.enzymeIndexs({'MG_352_DIMER'});            %HR   recU         Holliday junction endonuclease
            this.enzymeIndexs_hollidayJunctionHelicase       = this.enzymeIndexs({'MG_358_359_10MER'});        %HR   ruvAB        Holliday junction DNA helicase
            this.enzymeIndexs_exonuclease53                  = this.enzymeIndexs({'MG_262_MONOMER'});          %HR   pol I-like   5'-3' exonuclease, putative
            this.enzymeIndexs_polymerase                     = this.enzymeIndexs({'MG_001_MONOMER'});          %     dnaN         DNA polymerase III, beta subunit
            this.enzymeIndexs_ligase                         = this.enzymeIndexs({'MG_254_MONOMER'});          %     ligA         DNA ligase, NAD-dependent
            this.enzymeIndexs_phosphoesterase                = this.enzymeIndexs({'MG_190_MONOMER'});          %     mgpA         phosphoesterase
            this.enzymeIndexs_DisA                           = this.enzymeIndexs({'MG_105_OCTAMER'});          %     disA         DNA integrity scanning protein
            this.enzymeIndexs_RM_typeI                       = this.enzymeIndexs({'MG_438_MONOMER'});          %                  type I restriction modification DNA specificity domain protein
            this.enzymeIndexs_RM_typeII                      = this.enzymeIndexs({'MG_184_DIMER'});            %                  adenine-specific DNA modification methylase

            %% reactions
            %1. Find indices of reactions
            %2. Factor reactionStoichiometryMatrix into
            %   - reactionSmallMoleculeStoichiometryMatrix: the stochiometry of
            %     free metabolites in repair reactions
            %   - reactionDNAStoichiometryMatrix: the stoichiometry of DNA bases
            %     in repair reactions
            %3. Create reactionDNABase to represent the DNA base affected by
            %   each repair reaction
            this.reactionSmallMoleculeStoichiometryMatrix = zeros(size(this.reactionStoichiometryMatrix));
            this.reactionDNAStoichiometryMatrix           = zeros(size(this.reactionStoichiometryMatrix));
            this.reactionDNABase                          = zeros(size(this.reactionStoichiometryMatrix,2),1);

            %base excision repair (BER)
            this.reactionIndexs_BER                = find(strcmp(this.reactionTypes,'base excision repair') | strcmp(this.reactionTypes,'base excision repair, base excision'));
            this.reactionIndexs_BER_baseexcision   = find(strcmp(this.reactionTypes,'base excision repair, base excision'));
            this.reactionIndexs_BER_aplyase        = this.reactionIndexs({'AP_lyase'});
            this.reactionIndexs_BER_drpesterase    = this.reactionIndexs({'deoxyribosephosphodiesterase'});            
            this.reactionIndexs_BER_apendonuclease = this.reactionIndexs({'AP_endonuclease'});
            this.reactionIndexs_BER_dr5plyase      = this.reactionIndexs({'dRiboseP_lyase'});

            dnaSubstrateIndexs = [this.substrateIndexs_damagedDNMPs; this.substrateIndexs_dRibose5P_dRibose5P; this.substrateIndexs_DR5P];
            this.reactionDNAStoichiometryMatrix(dnaSubstrateIndexs, [this.reactionIndexs_BER_baseexcision;this.reactionIndexs_BER_aplyase;this.reactionIndexs_BER_apendonuclease]) = ...
                this.reactionStoichiometryMatrix(dnaSubstrateIndexs, [this.reactionIndexs_BER_baseexcision;this.reactionIndexs_BER_aplyase;this.reactionIndexs_BER_apendonuclease]);

            dnaSubstrateIndexs = [this.substrateIndexs_damagedDNMPs; this.substrateIndexs_dRibose5P_dRibose5P];
            this.reactionDNAStoichiometryMatrix(dnaSubstrateIndexs, [this.reactionIndexs_BER_drpesterase; this.reactionIndexs_BER_dr5plyase]) = ...
                this.reactionStoichiometryMatrix(dnaSubstrateIndexs, [this.reactionIndexs_BER_drpesterase; this.reactionIndexs_BER_dr5plyase]);            
            this.reactionDNAStoichiometryMatrix(this.substrateIndexs_DR5P, [this.reactionIndexs_BER_drpesterase; this.reactionIndexs_BER_dr5plyase]) = 1;

            %nucleotide excision repair (NER)
            this.reactionIndexs_NER                   = find(strcmp(this.reactionTypes,'nucleotide excision repair'));
            this.reactionIndexs_NER_incision          = this.reactionIndexs({'NER_DNAIncision'});
            this.reactionIndexs_NER_excision          = this.reactionIndexs({'NER_DNAExcision'});

            dnaSubstrateIndexs = [this.substrateIndexs_damagedDNMPs; this.substrateIndexs_dRibose5P_dRibose5P; this.substrateIndexs_DR5P];
            this.reactionDNAStoichiometryMatrix(dnaSubstrateIndexs, this.reactionIndexs_NER) = ...
                this.reactionStoichiometryMatrix(dnaSubstrateIndexs, this.reactionIndexs_NER);

            %cleavage
            this.reactionIndexs_DNACleavage = find(strcmp(this.reactionTypes,'DNA cleavage'));

            this.reactionDNAStoichiometryMatrix(this.substrateIndexs_dNpdNps, this.reactionIndexs_DNACleavage) = ...
                this.reactionStoichiometryMatrix(this.substrateIndexs_dNpdNps, this.reactionIndexs_DNACleavage);
            this.reactionDNAStoichiometryMatrix(this.substrateIndexs_dNMPs, this.reactionIndexs_DNACleavage) = ...
                0.5 * this.reactionStoichiometryMatrix(this.substrateIndexs_dNMPs, this.reactionIndexs_DNACleavage);

            %homologous recombination (HR) double strand break repair (DSBR)
            this.reactionIndexs_HR_dsbr               = find(strcmp(this.reactionTypes,'homologous recombination'));
            this.reactionIndexs_HR_DNAResection       = this.reactionIndexs({'HR_DNAResection_dAMP';'HR_DNAResection_dCMP';'HR_DNAResection_dGMP';'HR_DNAResection_dTMP'});
            this.reactionIndexs_HR_strandExchange     = this.reactionIndexs({'HR_strandExchange'});
            this.reactionIndexs_HR_junctionMigration  = this.reactionIndexs({'HR_junctionMigration'});
            this.reactionIndexs_HR_junctionResolution = this.reactionIndexs({'HR_junctionResolution'});

            dnaSubstrates = [this.substrateIndexs_dNMPs;this.substrateIndexs_dNpdNps;this.substrateIndexs_dRibose5P_dRibose5P;this.substrateIndexs_DR5P];
            partitions = [0.5*ones(length(this.substrateIndexs_dNMPs),1); ones(length(dnaSubstrates)-length(this.substrateIndexs_dNMPs),1)];
            this.reactionDNAStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_HR_dsbr) = ...
                repmat(partitions, 1, length(this.reactionIndexs_HR_dsbr)) .* ...
                this.reactionStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_HR_dsbr);
            
            this.hollidayJunctionResolutionSites = this.chromosome.sequence.findSubsequence(...
                this.HR_RecU_CleavageSequence, this.HR_RecU_CleavagePosition, true);

            %polymerization
            this.reactionIndexs_polymerization = find(strcmp(this.reactionTypes,'DNA polymerization'));
            dnaSubstrates = [this.substrateIndexs_dNMPs; this.substrateIndexs_dNpdNps];
            this.reactionDNAStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_polymerization) = ...
                this.reactionStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_polymerization);

            %ligation
            this.reactionIndexs_ligation = this.reactionIndexs({'DNA_ligation_repair'});
            dnaSubstrates = [this.substrateIndexs_DR5P; this.substrateIndexs_dRibose5P_dRibose5P];
            this.reactionDNAStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_ligation) = ...
                this.reactionStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_ligation);

            %restriction/modification
            this.reactionIndexs_RM                  = find(strcmp(this.reactionTypes, 'DNA restriction/modification'));
            this.reactionIndexs_RM_EcoD_Methylation = this.reactionIndexs({'DNA_RM_EcoD_Methylation'});
            this.reactionIndexs_RM_EcoD_Restriction = this.reactionIndexs({'DNA_RM_EcoD_Restriction'});
            this.reactionIndexs_RM_MunI_Methylation = this.reactionIndexs({'DNA_RM_MunI_Methylation'});
            this.reactionIndexs_RM_MunI_Restriction = this.reactionIndexs({'DNA_RM_MunI_Restriction'});

            dnaSubstrates = [this.substrateIndexs_undamagedNucleobases;this.substrateIndexs_damagedNucleobases;this.substrateIndexs_dRibose5P_dRibose5P;this.substrateIndexs_DR5P];
            this.reactionDNAStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_RM) = ...
                this.reactionStoichiometryMatrix(dnaSubstrates, this.reactionIndexs_RM);

            this.RM_MunI_MethylatedPositions = [
                this.RM_MunI_MethylationPosition;
                length(this.RM_MunI_RecognitionSequence)-this.RM_MunI_MethylationPosition+1]';
            this.RM_MunI_RestrictionPositions = [
                this.RM_MunI_RestrictionPosition;
                length(this.RM_MunI_RecognitionSequence)-this.RM_MunI_RestrictionPosition]';

            this.RM_EcoD_RecognitionSites = this.chromosome.sequence.findSubsequence(this.RM_EcoD_RecognitionSequence, 1);
            this.RM_EcoD_RecognitionSites = mod(...
                repmat(this.RM_EcoD_RecognitionSites,1,length(this.RM_EcoD_RecognitionSequence)) + ...
                repmat(0:length(this.RM_EcoD_RecognitionSequence)-1,size(this.RM_EcoD_RecognitionSites,1),1) - ...
                1, this.chromosome.sequenceLen)+1;

            this.RM_MunI_RecognitionSites = this.chromosome.sequence.findSubsequence(this.RM_MunI_RecognitionSequence, 1);
            this.RM_MunI_RecognitionSites = mod(...
                repmat(this.RM_MunI_RecognitionSites,1,length(this.RM_MunI_RecognitionSequence)) + ...
                repmat(0:length(this.RM_MunI_RecognitionSequence)-1,size(this.RM_MunI_RecognitionSites,1),1) - ...
                1, this.chromosome.sequenceLen)+1;

            % reactionSmallMoleculeStoichiometryMatrix
            this.reactionSmallMoleculeStoichiometryMatrix = ...
                this.reactionStoichiometryMatrix - ...
                this.reactionDNAStoichiometryMatrix;

            % reactionDNABase
            [metaboliteIdx, reactionIdx] = find(this.reactionDNAStoichiometryMatrix(this.substrateIndexs_damagedDNMPs, :)<0);
            this.reactionDNABase(reactionIdx) = this.substrateIndexs_damagedDNMPs(metaboliteIdx);
        end
    end

    %model
    methods
        %Calculate
        %- contribution to FBA objective
        %- minimum expression consistent with cell cycle length
        function [bmProd, byProd, minEnzExp, maxEnzExp] = calcResourceRequirements_LifeCycle(this, constants, ~)
            %expected rates of reactions (repair and restriction/modification)
            rates = this.calcExpectedReactionRates(constants);
            
            %substrate and byproducts: metabolic load of reactions
            bmProd = max(0, -this.reactionSmallMoleculeStoichiometryMatrix) * rates;
            byProd = max(0,  this.reactionSmallMoleculeStoichiometryMatrix) * rates;
            
            %enzymes
            minEnzExp = max(...
                this.reactionCatalysisMatrix' * (rates ./ this.enzymeBounds(:, 2)) / constants.states.Time.cellCycleLength * log(2), ...
                this.reactionCatalysisMatrix(this.reactionIndexs_RM_MunI_Methylation, :)' * ...
                    (rates(this.reactionIndexs_RM_MunI_Methylation) ./ this.enzymeBounds(this.reactionIndexs_RM_MunI_Methylation, 2)) / constants.states.Time.cellCycleLength * log(2) / ...
                    (exp(log(2) * (constants.states.Time.replicationInitiationDuration + constants.states.Time.replicationDuration) / constants.states.Time.cellCycleLength) - ...
                     exp(log(2) * constants.states.Time.replicationInitiationDuration / constants.states.Time.cellCycleLength)) ...
                );
            maxEnzExp = Inf(size(this.enzymeWholeCellModelIDs));
        end
        
        function repairRates = calcExpectedReactionRates(this, constants)
            repairRates = zeros(numel(this.reactionWholeCellModelIDs), 1);
            
            %% repair of damaged bases: calculate expected number of occurences of
            %each reaction over cell cycle
            c = this.chromosome;
            dmg = constants.processes.DNADamage;
            polDNA = collapse(c.polymerizedRegions);
            bases = 'ACGT';
            dntpComposition = [
                1 - c.sequenceGCContent
                c.sequenceGCContent
                c.sequenceGCContent
                1 - c.sequenceGCContent] / 2;
            
            for i = 1:size(dmg.reactionStoichiometryMatrix, 2)
                if dmg.reactionBounds(i, 2) == 0
                    continue;
                end
                
                %number of sites vulnerable to reaction per chromosome
                if ischar(dmg.reactionVulnerableMotifs{i})
                    nVulnerableSites = polDNA * prod(dntpComposition(ismembc(dmg.reactionVulnerableMotifs{i}, bases)));
                else
                    nVulnerableSites = collapse(...
                        dmg.reactionVulnerableMotifs{i} == c.(dmg.reactionVulnerableMotifTypes{i}) & ...
                        dmg.reactionVulnerableMotifs{i} == c.damagedSites_nonRedundant);
                end
                if nVulnerableSites == 0
                    continue;
                end
                
                %calculate rate, product of
                %- number of vulnerable site / chromosome
                %- integrated number of chromosomes over cell cycle
                %- reaction rate per vulnerable site (and per unit radiation
                %  for applicable reactions)
                %- amount of radition, for applicable reactions
                iRadLcl = find(dmg.reactionRadiationStoichiometryMatrix(:, i));
                
                damageRate = nVulnerableSites * ...
                    (1 * constants.states.Time.replicationInitiationDuration + 1.5 * constants.states.Time.replicationDuration + 2 * constants.states.Time.cytokinesisDuration) * ...
                    dmg.reactionBounds(i, 2);
                if ~isempty(iRadLcl)
                    iRadGbl = dmg.substrateStimulusGlobalCompartmentIndexs(dmg.substrateStimulusLocalIndexs == iRadLcl);
                    damageRate = damageRate * this.stimulus.values(iRadGbl);
                end
                
                switch dmg.reactionDamageTypes{i}
                    case 'abasicSites'
                        repairRates(this.reactionIndexs_BER_aplyase) = ...
                            repairRates(this.reactionIndexs_BER_aplyase) + ...
                            damageRate / 2;
                        repairRates(this.reactionIndexs_BER_drpesterase) = ...
                            repairRates(this.reactionIndexs_BER_drpesterase) + ...
                            damageRate / 2;
                        
                        repairRates(this.reactionIndexs_BER_apendonuclease) = ...
                            repairRates(this.reactionIndexs_BER_apendonuclease) + ...
                            damageRate / 2;
                        repairRates(this.reactionIndexs_BER_dr5plyase) = ...
                            repairRates(this.reactionIndexs_BER_dr5plyase) + ...
                            damageRate / 2;
                        
                        repairRates(this.reactionIndexs_polymerization) = ...
                            repairRates(this.reactionIndexs_polymerization) + ...
                            damageRate * dntpComposition;
                        repairRates(this.reactionIndexs_ligation) = ...
                            repairRates(this.reactionIndexs_ligation) + ...
                            damageRate;
                    case 'damagedBases'
                        repairRates(this.reactionIndexs_BER_baseexcision) = ...
                            repairRates(this.reactionIndexs_BER_baseexcision) + ...
                            damageRate / 2;
                        
                        repairRates(this.reactionIndexs_BER_aplyase) = ...
                            repairRates(this.reactionIndexs_BER_aplyase) + ...
                            damageRate / 2;
                        repairRates(this.reactionIndexs_BER_drpesterase) = ...
                            repairRates(this.reactionIndexs_BER_drpesterase) + ...
                            damageRate / 2;
                        
                        repairRates(this.reactionIndexs_BER_apendonuclease) = ...
                            repairRates(this.reactionIndexs_BER_apendonuclease) + ...
                            damageRate / 2;
                        repairRates(this.reactionIndexs_BER_dr5plyase) = ...
                            repairRates(this.reactionIndexs_BER_dr5plyase) + ...
                            damageRate / 2;
                        
                        repairRates(this.reactionIndexs_polymerization) = ...
                            repairRates(this.reactionIndexs_polymerization) + ...
                            damageRate * dntpComposition;
                        repairRates(this.reactionIndexs_ligation) = ...
                            repairRates(this.reactionIndexs_ligation) + ...
                            damageRate;
                    case 'intrastrandCrossLinks'
                        numExcisions = (this.NER_UvrABC_IncisionMargin5 + this.NER_UvrABC_IncisionMargin3 + 1);
                        
                        repairRates(this.reactionIndexs_NER_incision) = ...
                            repairRates(this.reactionIndexs_NER_incision) + ...
                            damageRate;
                        repairRates(this.reactionIndexs_NER_excision) = ...
                            repairRates(this.reactionIndexs_NER_excision) + ...
                            damageRate * ceil(numExcisions / this.NER_PcrA_StepSize);
                        repairRates(this.reactionIndexs_DNACleavage) = ...
                            repairRates(this.reactionIndexs_DNACleavage) + ...
                            damageRate * numExcisions * dntpComposition;
                        
                        repairRates(this.reactionIndexs_polymerization) = ...
                            repairRates(this.reactionIndexs_polymerization) + ...
                            damageRate * 2 * dntpComposition;
                        repairRates(this.reactionIndexs_ligation) = ...
                            repairRates(this.reactionIndexs_ligation) + ...
                            damageRate;
                    case 'strandBreaks'
                        repairRates(this.reactionIndexs_ligation) = ...
                            repairRates(this.reactionIndexs_ligation) + ...
                            damageRate;
                    otherwise
                        throw(MException('DNARepair:error', 'undefined damage reaction type %s', dmg.reactionDamageTypes{i}));
                end
            end
            
            %methylation of restriction/modification sites
            repairRates(this.reactionIndexs_RM_MunI_Methylation) = 2 * size(this.RM_MunI_RecognitionSites, 1);
        end
        
        %initialization: 
        %- Simulation initializeState initialize 1 undamaged chromosome
        %- Here we methylate all restriction/modification sites
        function initializeState(this)
            c = this.chromosome;
            iMet = this.substrateGlobalIndexs(this.substrateIndexs_m6AD);
            c.damagedBases(this.RM_MunI_RecognitionSites(:, this.RM_MunI_MethylatedPositions(1)), 1) = iMet;
            c.damagedBases(this.RM_MunI_RecognitionSites(:, this.RM_MunI_MethylatedPositions(2)), 2) = iMet;
        end

        %resource requirements
        function result = calcResourceRequirements_Current(this)
            c = this.chromosome;
            
            %% numbers of damages
            nGapSites = nnz(c.gapSites);
            nAbasicSites = nnz(c.abasicSites);
            if nnz(c.damagedSites)
                [posStrnds, bases] = find(c.damagedBases);
                nDamagedBases = numel(bases) - sum(...
                    bases == this.metabolite.m6ADIndexs & ...
                    ((isodd(posStrnds(:, 2)) & ismembc(posStrnds(:, 1), this.RM_MunI_RecognitionSites(:, this.RM_MunI_MethylatedPositions(1)))) | ...
                    (iseven(posStrnds(:, 2)) & ismembc(posStrnds(:, 1), this.RM_MunI_RecognitionSites(:, this.RM_MunI_MethylatedPositions(2))))));
            else
                nDamagedBases = 0;
            end
            nIntrastrandCrossLinks = nnz(c.intrastrandCrossLinks);
            nStrandBreaks = nnz(c.strandBreaks);
            if nStrandBreaks > 0
                nDSBR = nnz(c.doubleStrandBreaks);
            else
                nDSBR = 0;
            end
            nHJ = nnz(c.hollidayJunctions) / 2;
            
            %% reaction rates
            rates = zeros(size(this.reactionSmallMoleculeStoichiometryMatrix, 2), 1);
            
            %BER
            rates(this.reactionIndexs_BER_baseexcision)   = nDamagedBases;
            rates(this.reactionIndexs_BER_apendonuclease) = 0.5 * nAbasicSites;
            rates(this.reactionIndexs_BER_aplyase)        = 0.5 * nAbasicSites;
            rates(this.reactionIndexs_BER_drpesterase)    = 0.5 * nAbasicSites;
            rates(this.reactionIndexs_BER_dr5plyase)      = 0.5 * nAbasicSites;
            
            %NER
            nNER = nDamagedBases + nIntrastrandCrossLinks;
            nExcisions = (this.NER_UvrABC_IncisionMargin5 + this.NER_UvrABC_IncisionMargin3 + 1);
            rates(this.reactionIndexs_NER_incision) = nNER;
            rates(this.reactionIndexs_NER_excision) = nNER * nExcisions;
            rates(this.reactionIndexs_DNACleavage)  = nNER * nExcisions/4;
            
            %HR
            numResections = 2 * this.HR_PolA_ResectionLength;
            avgJunctionMigrationLength = c.sequenceLen / (size(this.hollidayJunctionResolutionSites, 2) / 2) / 2;
            rates(this.reactionIndexs_HR_DNAResection)       = nDSBR * numResections;
            rates(this.reactionIndexs_HR_strandExchange)     = nDSBR * 2 + nHJ * 2;
            rates(this.reactionIndexs_HR_junctionMigration)  = nHJ * avgJunctionMigrationLength / this.HR_RuvAB_JunctionMigrationHop;
            rates(this.reactionIndexs_HR_junctionResolution) = nHJ;
            
            %polymerization/ligation
            if nGapSites && nAbasicSites
                rates(this.reactionIndexs_polymerization) = nnz(c.gapSites & c.abasicSites);
            end
            rates(this.reactionIndexs_ligation) = nStrandBreaks;
            
            %restriction / modification
            rates(this.reactionIndexs_RM_MunI_Methylation) = nnz(c.hemiunmethylatedMunIRMSites);
            rates(this.reactionIndexs_RM_MunI_Restriction) = nnz(c.restrictableMunIRMSites);
            
            %% metabolic demands
            result = max(0, -this.reactionSmallMoleculeStoichiometryMatrix) * ...
                min(ceil(this.reactionCatalysisMatrix * this.enzymes * this.stepSizeSec), rates);
        end

        %simulation
        function evolveState(this)
            if nnz(this.chromosome.damagedSites) == 0
                %there is no damage, no repair necessary
                if this.randStream.rand > 0.5
                    this.evolveState_Modification();
                    this.evolveState_Restriction();
                else
                    this.evolveState_Restriction();
                    this.evolveState_Modification();
                end
            else
                %there is damage, repair necessary
                subfunctions = {
                    @this.evolveState_BER;          %base excision repair (BER)
                    @this.evolveState_NER;          %nucleotide excision repair (NER)
                    @this.evolveState_HR;           %homologous recombination (HR) double strand break repair (DSBR)
                    @this.evolveState_Polymerize;   %polymerize DNA
                    @this.evolveState_Ligate;       %ligate DNA
                    @this.evolveState_Modification; %Modification
                    @this.evolveState_Restriction;  %Restriction
                    @this.evolveState_DisA;         %DNA integrity scanning protein
                    };
                order = this.randStream.randperm(numel(subfunctions));
                for i = 1:numel(subfunctions)
                    subfunctions{order(i)}();
                end
            end
        end
    end

    %model helper functions
    methods
        %base excision repair
        function evolveState_BER(this)
            c = this.chromosome;
            
            %1. Base excision by
            %   - fpg: FAPyA, FAPyG, 8-oxo-G, 8-oxo-A (MG_498_MONOMER)
            %   - ung: uracil, ho5U (MG_097_MONOMER)

            %Loop over base excision enzymes (fpg, ung)
            if nnz(c.damagedBases)
                randOrder = this.randStream.randperm(length(this.enzymeIndexs_BER_baseExcision));
                for idx = 1:length(this.enzymeIndexs_BER_baseExcision)
                    i = randOrder(idx);
                    ezIdx = this.enzymeIndexs_BER_baseExcision(i);
                    
                    %short cut if no enzyme
                    if this.enzymes(ezIdx) == 0; continue; end
                    
                    %Find damaged bases that enzyme can excise
                    rxIdxs = this.reactionIndexs_BER_baseexcision(this.reactionCatalysisMatrix(this.reactionIndexs_BER_baseexcision, ezIdx) ~= 0);
                    [positionsStrands, damagedBaseGlobalIndexs] = find(c.damagedBases);
                    damagedBaseLocalIndexs = ismembc2(damagedBaseGlobalIndexs, this.substrateGlobalIndexs);
                    [tfs, idxs] = ismember(damagedBaseLocalIndexs, this.reactionDNABase(rxIdxs));
                    positionsStrands(~tfs, :) = [];
                    reactions = rxIdxs(idxs(tfs));
                    
                    %short cut if no positions to be repaired
                    if isempty(positionsStrands); continue; end                    
                    
                    %Randomly select bases to excise up to available resources,
                    %(note this is valid because each reaction has the same
                    %enzymatic rate and free metabolite reactants)
                    numReactions = max(0, floor(min([
                        numel(reactions);
                        this.randStream.stochasticRound(this.enzymes(ezIdx) * this.enzymeBounds(reactions(1), 2) * this.stepSizeSec);
                        this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, reactions(1)))])));
                    if numReactions == 0; continue; end         
                    
                    [~, idxs, positionsStrands] = this.bindProteinToChromosome(positionsStrands, ...
                        ezIdx, numReactions, [], false, true, 1, false, 1);
                    if isempty(idxs); continue; end
                    reactions = reactions(idxs, :);
                    
                    %update state
                    this.substrates = this.substrates + ...
                        sum(this.reactionSmallMoleculeStoichiometryMatrix(:, reactions), 2);
                    c.damagedBases(positionsStrands) = 0;
                    c.abasicSites( positionsStrands) = 1;
                end
            end

            %2. Sugar excision
            %   a. i.  3'-AP lyase Fpg (MG_498)
            %      ii. 5'-deoxyribosephosphodiesterase Nfo (MG_235)
            %   b. i.  5'-AP endonuclease Nfo (MG_235)
            %      ii. 3'-(deoxyribose-5'-phosphate) lyase dnaN (MG_001)

            %3'-AP lyase (MG_498) / 5'-AP endonuclease Nfo (MG_235)
            if nnz(c.abasicSites)
                rxIdxs = [this.reactionIndexs_BER_aplyase;this.reactionIndexs_BER_apendonuclease];
                randOrder = this.randStream.randperm(length(rxIdxs));
                for i = 1:length(rxIdxs)
                    rxIdx = rxIdxs(randOrder(i));
                    ezIdx = find(this.reactionCatalysisMatrix(rxIdx,:));
                    if this.enzymes(ezIdx) == 0; continue; end
                    
                    positionsStrands = find(c.abasicSites & xor(c.abasicSites,  c.strandBreaks3 | c.strandBreaks5));
                    if isempty(positionsStrands); continue; end
                    
                    numReactions = max(0, floor(min([
                        size(positionsStrands, 1);
                        this.randStream.stochasticRound(this.enzymes(ezIdx) * this.enzymeBounds(rxIdx, 2) * this.stepSizeSec);
                        this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, rxIdx))])));
                    if numReactions == 0; continue; end
                    
                    if rxIdx == this.reactionIndexs_BER_aplyase
                        checkPositionsStrands = positionsStrands;
                        checkPositionsStrands(mod(positionsStrands(:,2),2)==0, 1) = checkPositionsStrands(mod(positionsStrands(:,2),2)==0, 1) - 1;
                        [~, idxs, ~, numReactions] = this.bindProteinToChromosome(checkPositionsStrands, ...
                            ezIdx, numReactions, [], false, true, 2, false, 1);
                        if numReactions == 0; continue; end
                        positionsStrands = positionsStrands(idxs, :);
                        
                        c.strandBreaks(c.shiftPositionsStrandsBond3Prime(positionsStrands)) = 1;
                        c.damagedSugarPhosphates(positionsStrands) = 0;
                    else
                        checkPositionsStrands = positionsStrands;
                        checkPositionsStrands(mod(positionsStrands(:,2),2)==1, 1) = checkPositionsStrands(mod(positionsStrands(:,2),2)==1, 1) - 1;
                        [~, idxs, ~, numReactions] = this.bindProteinToChromosome(checkPositionsStrands, ...
                            ezIdx, numReactions, [], false, true, 2, false, [1 2]);
                        if numReactions == 0; continue; end
                        positionsStrands = positionsStrands(idxs, :);
                        
                        c.strandBreaks(c.shiftPositionsStrandsBond5Prime(positionsStrands)) = 1;
                        c.damagedSugarPhosphates(positionsStrands) = 0;
                    end
                    
                    this.substrates = this.substrates + ...
                        numReactions * this.reactionSmallMoleculeStoichiometryMatrix(:, rxIdx);
                end
            end
            
            %5'-deoxyribosephosphodiesterase Nfo (MG_235)
            if nnz(c.abasicSites) && nnz(c.strandBreaks)
                positionsStrands = find(...
                    c.abasicSites & ...
                    c.strandBreaks3);
                if ~isempty(positionsStrands)
                    
                    numReactions = max(0, floor(min([
                        size(positionsStrands, 1);
                        this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_apurinicEndonuclease) * this.enzymeBounds(this.reactionIndexs_BER_drpesterase, 2) * this.stepSizeSec);
                        this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_BER_drpesterase))])));
                    
                    checkPositionsStrands = positionsStrands;
                    checkPositionsStrands(:, 1) = checkPositionsStrands(:, 1) - 1;
                    [~, idxs, ~, numReactions] = this.bindProteinToChromosome(checkPositionsStrands, ...
                        this.enzymeIndexs_apurinicEndonuclease, numReactions, [], false, true, 2, false, [1 2 3]);
                    if numReactions > 0
                        positionsStrands = positionsStrands(idxs, :);
                        
                        c.damagedSugarPhosphates(positionsStrands) = 0;
                        c.strandBreaks(c.shiftPositionsStrandsBond5Prime(positionsStrands)) = 1;
                        c.gapSites(positionsStrands) = 1;
                        
                        this.substrates = this.substrates + ...
                            numReactions * this.reactionSmallMoleculeStoichiometryMatrix(:,this.reactionIndexs_BER_drpesterase);
                    end
                end
            end
            
            %3'-(deoxyribose-5'-phosphate) lyase dnaN (MG_001)
            if nnz(c.abasicSites) && nnz(c.strandBreaks)
                positionsStrands = find(c.abasicSites & c.strandBreaks5);
                if ~isempty(positionsStrands)
                    
                    numReactions = max(0, floor(min([
                        size(positionsStrands, 1);
                        this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_polymerase) * this.enzymeBounds(this.reactionIndexs_BER_dr5plyase, 2) * this.stepSizeSec);
                        this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_BER_dr5plyase))])));
                    
                    checkPositionsStrands = positionsStrands;
                    checkPositionsStrands(:, 1) = checkPositionsStrands(:, 1) - 1;
                    [~, idxs, ~, numReactions] = this.bindProteinToChromosome(checkPositionsStrands, ...
                        this.enzymeIndexs_polymerase, numReactions, [], false, true, 2, false, [1 2 3]);
                    if numReactions > 0
                        positionsStrands = positionsStrands(idxs, :);
                        
                        c.damagedSugarPhosphates(positionsStrands) = 0;
                        c.strandBreaks(c.shiftPositionsStrandsBond3Prime(positionsStrands)) = 1;
                        c.gapSites(positionsStrands) = 1;
                        
                        this.substrates = this.substrates + ...
                            numReactions * this.reactionSmallMoleculeStoichiometryMatrix(:,this.reactionIndexs_BER_dr5plyase);
                    end
                end
            end
        end

        %nucleotide excision repair:
        %1. UvrABC (MG_073, MG_206, MG_421) cleaves DNA 3' and 5' to lesion
        %2. Helicase PcrA (MG_244) excises cleaved DNA
        %3. Cleavage excised oligonucleotide by MgpA (MG_190)
        %4. 5'-3' Polymerization by dnaN (MG_001)
        %5. Ligation by ligA (MG_254). See DDR section for details.
        %6. Catabolism and export of damaged nucleobases and nucleosides by
        %   metabolic process.
        %
        %evolveState_NER models steps 1-3. evolveState_PolymeraseLigate models
        %steps 4-6.
        function evolveState_NER(this)            
            %% for convenience
            c = this.chromosome;
            
            %% stop early
            %no enzyme
            rxIdxs = [this.reactionIndexs_NER_incision; this.reactionIndexs_NER_excision; this.reactionIndexs_DNACleavage];
            if ~all(this.reactionCatalysisMatrix(rxIdxs, :) * this.enzymes)
                return;
            end
            
            %no damage
            if nnz(c.damagedBases) == 0 && nnz(c.intrastrandCrossLinks) == 0
                return;
            end

            %% damaged sites: positions and strands
            damagedPositionsStrands = setdiff(...
                find(xor(c.damagedBases, c.intrastrandCrossLinks)), ...
                find(c.damagedBases == this.substrateGlobalIndexs(this.substrateIndexs_m6AD)), ...
                'rows');
            if isempty(damagedPositionsStrands)
                return;
            end

            %% exclude methylated restriction/modification sites
            % Note: this implements the approximation that the rate of
            % methylation of hemimethylated restriction/modification sites is
            % greater their rate of demethylation by the DNA repair machinery
            rmPositionsStrands = [...
                reshape(this.RM_MunI_RecognitionSites(:, this.RM_MunI_MethylatedPositions), [], 1) ...
                reshape(repmat([1 2], size(this.RM_MunI_RecognitionSites, 1), 1), [], 1)];
            rmPositionsStrands(...
                c.damagedBases(rmPositionsStrands) == this.substrateGlobalIndexs(this.substrateIndexs_m6AD), :) = [];
            
            damagedPositionsStrands(edu.stanford.covert.util.SparseMat.ismember_subs(damagedPositionsStrands, rmPositionsStrands, [c.sequenceLen c.nCompartments]), :) = [];
            
            %% possible excision, incision sites
            lengths = 1 + (this.NER_UvrABC_IncisionMargin5 + this.NER_UvrABC_IncisionMargin3 + 1);
            
            excisedPositions = 2:lengths;
            incisedPositions = [1 lengths];
            numExcisions = numel(excisedPositions);
            numIncisions = numel(incisedPositions);
            
            positionsStrands = damagedPositionsStrands;
            ignoreDamageFilter = ones(size(positionsStrands, 1), 2);
            
            idxs = find(c.intrastrandCrossLinks(damagedPositionsStrands));
            ignoreDamageFilter(idxs, 2) = ignoreDamageFilter(idxs, 2) + (2 * (mod(damagedPositionsStrands(idxs, 2), 2) == 1) - 1);

            %% calculate maximum number of sites that can be repaired
            rxIdxs = [this.reactionIndexs_NER_incision; this.reactionIndexs_NER_excision; this.reactionIndexs_DNACleavage];
            rxCounts = [1; ceil(numExcisions / this.NER_PcrA_StepSize); ceil(numExcisions / 4 * ones(4,1))];
            
            numReactions = max(0, floor(min([...
                size(positionsStrands, 1);
                this.randStream.stochasticRound((this.reactionCatalysisMatrix(rxIdxs, :) * this.enzymes * this.stepSizeSec) .* (this.enzymeBounds(rxIdxs, 2) .* rxCounts));
                this.substrates ./ (max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, rxIdxs)) * rxCounts)])));
            if numReactions == 0
                return;
            end
            
            %% randomly select sites to repair
            [~, idxs, positionsStrands] = this.bindProteinToChromosome(positionsStrands, ...
                any(this.reactionCatalysisMatrix(rxIdxs, :), 1), numReactions, [], ...
                false, true, lengths, false, ignoreDamageFilter);
            if isempty(idxs)
                return;
            end
            damagedPositionsStrands = damagedPositionsStrands(idxs, :);
            
            %% update state
            numReactions = size(positionsStrands, 1);
            positionsStrands(mod(positionsStrands(:, 2), 2) == 1, 1) = positionsStrands(mod(positionsStrands(:, 2), 2) == 1, 1) - this.NER_UvrABC_IncisionMargin5 - 1;
            positionsStrands(mod(positionsStrands(:, 2), 2) == 0, 1) = positionsStrands(mod(positionsStrands(:, 2), 2) == 0, 1) - this.NER_UvrABC_IncisionMargin3 - 1;
            
            %metabolites
            rxCounts(1) = numReactions;
            rxCounts(2) = ceil(numExcisions / this.NER_PcrA_StepSize) * numReactions;
            rxCounts(3:6) = c.sequence.subsequenceBaseCounts(...
                reshape(repmat(positionsStrands(:, 1), 1, numExcisions) + repmat(excisedPositions - 1, numReactions, 1), [], 1), ...
                repmat(positionsStrands(:,2), numExcisions, 1));
            this.substrates = this.substrates + ...
                this.reactionSmallMoleculeStoichiometryMatrix(:, rxIdxs) * rxCounts;

            %correct metabolites for damages bases
            damages = c.damagedBases(damagedPositionsStrands);
            idxs = find(damages);
            undamagedBaseCounts = c.sequence.subsequenceBaseCounts(damagedPositionsStrands(idxs, :));
            [damages, damageCounts] = edu.stanford.covert.util.countUnique(damages(idxs, :));
            damages = ismembc2(damages, this.substrateGlobalIndexs);
            
            this.substrates(this.substrateIndexs_dNMPs) = this.substrates(this.substrateIndexs_dNMPs) - undamagedBaseCounts;
            this.substrates(damages) = this.substrates(damages) + damageCounts;
            
            %correct metabolites for intrastrand cross links
            damages = c.intrastrandCrossLinks(damagedPositionsStrands);
            idxs = find(damages);
            undamagedBaseCounts = c.sequence.subsequenceBaseCounts(...
                repmat(damagedPositionsStrands(idxs, 1), 1, 2) + repmat(2 * (mod(damagedPositionsStrands(idxs, 2), 2) == 1) - 1, 1, 2) .* repmat(0:1, numel(idxs), 1), ...
                damagedPositionsStrands(idxs, 2));
            [damages, damageCounts] = edu.stanford.covert.util.countUnique(damages(idxs, :));
            damages = ismembc2(damages, this.substrateGlobalIndexs);
            
            this.substrates(this.substrateIndexs_dNMPs) = this.substrates(this.substrateIndexs_dNMPs) - undamagedBaseCounts;
            this.substrates(damages) = this.substrates(damages) + damageCounts;
            this.substrates(this.substrateIndexs_water) = this.substrates(this.substrateIndexs_water) + sum(damageCounts);
            this.substrates(this.substrateIndexs_hydrogen) = this.substrates(this.substrateIndexs_hydrogen) - sum(damageCounts);
            
            %DNA
            incisedPositionsStrands = [...
                reshape(repmat(positionsStrands(:,1), 1, numIncisions) + repmat(incisedPositions-1, numReactions, 1), [], 1) ...
                repmat(positionsStrands(:,2), numIncisions, 1)];
            excisedPositionsStrands = [...
                reshape(repmat(positionsStrands(:,1), 1, numExcisions) + repmat(excisedPositions-1, numReactions, 1), [], 1) ...
                repmat(positionsStrands(:,2), numExcisions, 1)];
            
            c.strandBreaks(          incisedPositionsStrands) = 1;
            c.gapSites(              excisedPositionsStrands) = 1;
            c.abasicSites(           excisedPositionsStrands) = 1;
            c.damagedBases(          excisedPositionsStrands) = 0;
            c.intrastrandCrossLinks( excisedPositionsStrands) = 0;
        end

        %homologous recombination repair
        function evolveState_HR(this)
            c = this.chromosome;                       

            %% 1. 5'-3' resection (polI-like, MG_262),
            %  2. Strand exchange (recA, MG_339)
            if nnz(c.strandBreaks) && nnz(c.doubleStrandBreaks)
                %find double strand breaks
                positionsChromosomes = find(c.doubleStrandBreaks(:, 1:2:end));
                
                %possible sites of resection
                numResections = 2*this.HR_PolA_ResectionLength;
                
                %randomly select double strand breaks to repair, up to limit of
                %available metabolites and enzymes
                rxIdxs = [this.reactionIndexs_HR_strandExchange; this.reactionIndexs_HR_DNAResection(1)];
                rxCounts = [2; numResections];
                numReactions = max(0,floor(min([
                    size(positionsChromosomes,1);
                    this.substrates ./ (max(0,-this.reactionSmallMoleculeStoichiometryMatrix(:,rxIdxs))*rxCounts);
                    this.randStream.stochasticRound((this.reactionCatalysisMatrix(rxIdxs,:)*this.enzymes*this.stepSizeSec).*(this.enzymeBounds(rxIdxs,2) .* rxCounts));
                    floor(this.enzymes(this.enzymeIndexs_recombinationStrandExchange) / (2*ceil(numResections/2/this.HR_RecA_Spacing)))])));
                
                [~, idxs, ~, numReactions] = this.bindProteinToChromosome(...
                    [positionsChromosomes(:,1) - this.HR_PolA_ResectionLength 2*positionsChromosomes(:,2)], ...
                    this.enzymeIndexs_exonuclease53, numReactions, [], ...
                    false, true, 2*this.HR_PolA_ResectionLength, false, this.HR_PolA_ResectionLength + [1 2]);
                if numReactions > 0
                    positionsChromosomes = positionsChromosomes(idxs,:);
                    positions = positionsChromosomes(:, 1);
                    chrs      = positionsChromosomes(:, 2);
                    numDSBs = length(idxs);
                    
                    %update state
                    resectedPositions1    = repmat(positions, 1, numResections/2) + repmat(1:this.HR_PolA_ResectionLength,    numDSBs, 1);
                    resectedPositions2    = repmat(positions, 1, numResections/2) + repmat(-this.HR_PolA_ResectionLength+1:0, numDSBs, 1);
                    resectedEndPositions1 =        positions                      +         this.HR_PolA_ResectionLength;
                    resectedEndPositions2 =        positions                      +        -this.HR_PolA_ResectionLength;
                    
                    c.gapSites(   reshape(resectedPositions1, [], 1), 1) = 1;
                    c.gapSites(   reshape(resectedPositions2, [], 1), 2) = 1;
                    c.abasicSites(reshape(resectedPositions1, [], 1), 1) = 1;
                    c.abasicSites(reshape(resectedPositions2, [], 1), 2) = 1;
                    c.hollidayJunctions(  resectedEndPositions1,     1) = 1;
                    c.hollidayJunctions(  resectedEndPositions2,     2) = 1;
                    
                    rxIdxs = [this.reactionIndexs_HR_strandExchange; this.reactionIndexs_HR_DNAResection];
                    rxCounts = [2*numReactions;
                        c.sequence.subsequenceBaseCounts(resectedPositions1, 1) + c.sequence.subsequenceBaseCounts(resectedPositions2, 2)];
                    this.substrates = this.substrates + ...
                        this.reactionSmallMoleculeStoichiometryMatrix(:, rxIdxs) * rxCounts;
                    
                    nRecA = ceil(numResections / 2 / this.HR_RecA_Spacing);
                    recAPositions1 = repmat(positions, 1, nRecA) + repmat(this.randStream.stochasticRound((1:nRecA)*this.HR_PolA_ResectionLength / nRecA),            numDSBs, 1);
                    recAPositions2 = repmat(positions, 1, nRecA) + repmat(this.randStream.stochasticRound((-nRecA+1:0)*(this.HR_PolA_ResectionLength-1) / (nRecA-1)), numDSBs, 1);
                    this.bindProteinToChromosome(...
                        [reshape(recAPositions1, [], 1) repmat(2*chrs-1, nRecA, 1); reshape(recAPositions2, [], 1) repmat(2*chrs, nRecA, 1)], ...
                        this.enzymeIndexs_recombinationStrandExchange, [], [], ...
                        true, true, 1, false, -this.HR_PolA_ResectionLength-1:this.HR_PolA_ResectionLength);
                end
            end

            %% 3. 5'-3' polymerization (dnaN, MG_001)
            %  4. Ligation (ligA, MG_254)
            %    simulated by evolveState_Polymerize/Ligate

            %% 5. Second strand exchange (recA, MG_339)
            %  6. Holliday junction migration (ruvAB, MG_358, MG_359)
            %  7. Holliday junction resolution (recU, MG_352)

            if nnz(c.hollidayJunctions)
                %find holiday junctions
                numResections = 2*this.HR_PolA_ResectionLength;
                positionsChromosomes = find(...
                    c.hollidayJunctions(:, 1:2:end) & ...
                    vertcat(c.hollidayJunctions(end-numResections+1:end,2:2:end), c.hollidayJunctions(1:end-numResections, 2:2:end)));
                
                %randomly reorder holliday junctions
                randomIdxs  = this.randStream.randperm(size(positionsChromosomes,1));
                positionsChromosomes = positionsChromosomes(randomIdxs,:);
                positions = positionsChromosomes(:, 1);
                chrs = positionsChromosomes(:, 2);
                
                %loop over holliday junctions
                for i = 1:numel(positions)
                    %formation site
                    hollidayJunctionFormationSite = mod(positions(i) + [0; -numResections] - 1, c.sequenceLen) + 1;
                    
                    %find nearest resolution site
                    hollidayJunctionResolutionSite = zeros(2,1);
                    if hollidayJunctionFormationSite(1) > this.hollidayJunctionResolutionSites(find(this.hollidayJunctionResolutionSites(:, 2) == 1, 1, 'last'), 1)
                        hollidayJunctionResolutionSite(1) = this.hollidayJunctionResolutionSites(...
                            find(this.hollidayJunctionResolutionSites(:, 2) == 1, 1, 'first'), 1);
                    else
                        hollidayJunctionResolutionSite(1) = this.hollidayJunctionResolutionSites(...
                            find(this.hollidayJunctionResolutionSites(:, 2) == 1 & ...
                            this.hollidayJunctionResolutionSites(:, 1) > hollidayJunctionFormationSite(1), 1, 'first'), 1);
                    end
                    if hollidayJunctionFormationSite(2) < this.hollidayJunctionResolutionSites(find(this.hollidayJunctionResolutionSites(:, 2) == 2, 1, 'first'), 1)
                        hollidayJunctionResolutionSite(2) = this.hollidayJunctionResolutionSites(...
                            find(this.hollidayJunctionResolutionSites(:, 2) == 2, 1, 'last'), 1);
                    else
                        hollidayJunctionResolutionSite(2) = this.hollidayJunctionResolutionSites(...
                            find(this.hollidayJunctionResolutionSites(:, 2) == 2 & ...
                            this.hollidayJunctionResolutionSites(:, 1) < hollidayJunctionFormationSite(2), 1, 'last'), 1);
                    end
                    
                    %junction migration steps
                    junctionMigrationLengths = abs(hollidayJunctionResolutionSite-hollidayJunctionFormationSite);
                    junctionMigrationHops = sum(this.randStream.stochasticRound(junctionMigrationLengths / this.HR_RuvAB_JunctionMigrationHop));
                    
                    %stop if insufficient resources
                    rxIdxs   = [this.reactionIndexs_HR_strandExchange; this.reactionIndexs_HR_junctionMigration; this.reactionIndexs_HR_junctionResolution];
                    rxCounts = [2; junctionMigrationHops; 1];
                    if ...
                            any(this.substrates < max(0,-this.reactionSmallMoleculeStoichiometryMatrix(:,rxIdxs))*rxCounts) || ...
                            any(this.randStream.stochasticRound(this.reactionCatalysisMatrix(rxIdxs,:) * this.enzymes * this.stepSizeSec .* this.enzymeBounds(rxIdxs,2)) < 1)
                        continue;
                    end
                    
                    %stop if site isn't accessible
                    resolutionRegionLength = mod(hollidayJunctionResolutionSite(1) - hollidayJunctionResolutionSite(2) + 1 -1, c.sequenceLen) + 1;
                    ignoreDamageFilter = mod(repmat(hollidayJunctionFormationSite, 1, 3) + repmat(-1:1, 2, 1) - hollidayJunctionResolutionSite(2) + 1 -1, c.sequenceLen) + 1;
                    if ~this.bindProteinToChromosome([hollidayJunctionResolutionSite(2) 2*chrs(i)], ...
                            this.enzymeIndexs_hollidayJunctionHelicase, 1, [], ...
                            false, true, resolutionRegionLength, false, reshape(ignoreDamageFilter, 1, []))
                        continue;
                    end
                    
                    %update state
                    this.substrates = this.substrates + ...
                        this.reactionSmallMoleculeStoichiometryMatrix(:,rxIdxs)*rxCounts;
                    
                    c.hollidayJunctions([hollidayJunctionFormationSite 2*chrs(i) + [-1;0]]) = 0;
                    c.strandBreaks([hollidayJunctionResolutionSite 2*chrs(i) + [-1;0]]) = 1;
                end
            end

            %% 8. Ligation (ligA, MG_254)
            %  9. Catabolism
            %     simulated by evolveState_Polymerize/Ligate, metabolism process
        end

        % polymerize DNA
        function evolveState_Polymerize(this)
            c = this.chromosome;
            
            if nnz(c.gapSites) == 0 || nnz(c.abasicSites) == 0 || nnz(c.strandBreaks) == 0
                return;
            end
            
            %find regions that need to be polymerized
            gapStarts = find(c.gapSites & c.abasicSites & c.strandBreaks5);
            if isempty(gapStarts)
                return; 
            end
            gapNotStarts = find(c.gapSites & c.abasicSites & c.gapSites5 & c.abasicSites5);
            gapNotStarts(find(c.strandBreaks5(gapNotStarts)), :) = []; %#ok<FNDSB>
            gaps = edu.stanford.covert.util.SparseMat.sort_subs([gapStarts;gapNotStarts], [c.sequenceLen c.nCompartments]);
            gaps(...
                c.damagedSugarPhosphates3(gaps) | ...
                c.damagedSugarPhosphates5(gaps) | ...
                c.damagedBases(           gaps) | ...
                c.intrastrandCrossLinks3( gaps) | ...
                c.intrastrandCrossLinks5( gaps), :)=[];
            
            [positions, lengths, strands, sequencesCell] = c.sequence.locateFeatures(gaps);
            dirs = 2 * (mod(strands, 2) == 1) - 1;
            
            %polymerize regions in random order
            polymerase = this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_polymerase) * this.enzymeBounds(this.reactionIndexs_polymerization(1), 2) * this.stepSizeSec);
            randOrder = this.randStream.randperm(numel(positions));
            [~, footprint3Prime, footprint5Prime] = c.getDNAFootprint(this.enzymeGlobalIndexs(this.enzymeIndexs_polymerase), []);
            for j = 1:numel(positions)
                %% polymerize regions in random order
                i = randOrder(j);
                
                %% calculate extent of polymerization
                %limit extent by available polymerase and metabolites
                polymerizedBases = edu.stanford.covert.cell.sim.util.polymerize(...
                    sequencesCell{i}(1: min(lengths(i), polymerase)), ...
                    this.substrates(this.substrateIndexs_dNTPs), 'ACGT', char(0), 0, 0, this.randStream);                
                if polymerizedBases == 0
                    continue;
                end
                
                %damage filter
                ignoreDamageMin = -1;
                ignoreDamageMax = lengths(i)+1;
                if mod(strands(i), 2)
                    ignoreDamageMin = ignoreDamageMin - footprint5Prime;
                    ignoreDamageMax = ignoreDamageMax + footprint3Prime;
                else
                    ignoreDamageMin = ignoreDamageMin - footprint3Prime;
                    ignoreDamageMax = ignoreDamageMax + footprint5Prime;
                end
                ignoreDamageFilter = dirs(i) * (ignoreDamageMin:ignoreDamageMax) + 1;
                
                %limit extent by accessibility of sites to DNA polymerase
                [~, ~, ~, ~, polymerizedBases] = this.bindProteinToChromosome(c.shiftPositionsStrandsBond5Prime([positions(i) strands(i)]), this.enzymeIndexs_polymerase, 1, [], ...
                    false, true, dirs(i) * (polymerizedBases + 1), true, ignoreDamageFilter);
                
                polymerizedBases = min(abs(polymerizedBases), lengths(i));
                
                if polymerizedBases == 0
                    continue;
                end
                
                %% update state
                %calculate base costs
                [~, ~, baseCosts] = edu.stanford.covert.cell.sim.util.polymerize(...
                    sequencesCell{i}(1:polymerizedBases), ...
                    this.substrates(this.substrateIndexs_dNTPs), 'ACGT', char(0), 0, 0, this.randStream);
                
                %decrement enzyme
                polymerase = polymerase - polymerizedBases;
                
                %update metabolites
                this.substrates = this.substrates + ...
                    this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_polymerization) * baseCosts;
                
                %update chromosome state
                pos = positions(i) + dirs(i) * (0:polymerizedBases-1);
                c.gapSites(   pos, strands(i)) = 0;
                c.abasicSites(pos, strands(i)) = 0;
                c.strandBreaks(c.shiftPositionsStrandsBond5Prime([pos(1)   strands(i)])) = 0;
                c.strandBreaks(c.shiftPositionsStrandsBond3Prime([pos(end) strands(i)])) = 1;
            end
        end

        % ligate DNA
        %
        %Note: this function is redundant with ligateDNA in Replication
        function evolveState_Ligate(this)
            c = this.chromosome;

            if nnz(c.strandBreaks) == 0
                return;
            end
            
            positionsStrands = find(c.singleStrandBreaks);
            if isempty(positionsStrands)
                return;
            end
            
            numReactions = max(0, floor(min([
                size(positionsStrands, 1);
                this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_ligase) * this.stepSizeSec * this.enzymeBounds(this.reactionIndexs_ligation, 2));
                this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_ligation))])));
            if numReactions == 0
                return
            end
            
            [~, ~, positionsStrands, numReactions] = this.bindProteinToChromosome(...
                positionsStrands, this.enzymeIndexs_ligase, numReactions, [], false, true, 1, false, [0 1 2]);            
            if numReactions == 0
                return;
            end
            
            c.strandBreaks(positionsStrands) = 0;
            
            this.substrates = this.substrates + numReactions * ...
                this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_ligation);
        end

        %bind DNA integrity scanning protein to strand breaks, base
        %damage, and cross links
        function evolveState_DisA(this)
            %find locations of damages
            positionsStrands = find(this.chromosome.damagedSites_excm6AD);
            if isempty(positionsStrands)
                return;
            end
            
            %bind free DisA to accessible damaged sites
            this.bindProteinToChromosome(positionsStrands, this.enzymeIndexs_DisA, ...
                this.enzymes(this.enzymeIndexs_DisA), [], true, true, 1, false, 1);
        end
        
        function evolveState_Modification(this)
            c = this.chromosome;
            
            %% EcoD Type I restriction/modification system
            %  M. genitalium contains only the DNA binding subunit
            
            %% MunI Type II restriction/modification system
            %methylate hemi-unmethylated restriction/modification sites
            posStrnds = find(c.hemiunmethylatedMunIRMSites);
            if isempty(posStrnds)
                return;
            end
            
            numReactions = max(0, floor(min([
                size(posStrnds, 1);
                this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_RM_MunI_Methylation));
                this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_RM_typeII) * this.stepSizeSec * this.enzymeBounds(this.reactionIndexs_RM_MunI_Methylation, 2))])));
            if numReactions  == 0
                return;
            end
            
            [~, ~, posStrnds, numReactions] = this.bindProteinToChromosome(...
                posStrnds, this.enzymeIndexs_RM_typeII, numReactions, [], false, true, 1, false, [0 1 2]);
            if numReactions == 0
                return;
            end
            
            c.damagedBases(posStrnds) = this.substrateGlobalIndexs(this.substrateIndexs_m6AD);
            
            this.substrates = this.substrates + ...
                numReactions * this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_RM_MunI_Methylation);
        end
        
        function evolveState_Restriction(this)
            c = this.chromosome;
            
            %% EcoD Type I restriction/modification system
            %  M. genitalium contains only the DNA binding subunit
            
            %% MunI Type II restriction/modification system
            %cleave unmethylated restriction/modification sites
            posStrnds = find(c.restrictableMunIRMSites);
            if isempty(posStrnds)
                return;
            end
            
            numReactions = max(0, floor(min([
                size(posStrnds, 1);
                this.substrates ./ max(0, -this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_RM_MunI_Restriction));
                this.randStream.stochasticRound(this.enzymes(this.enzymeIndexs_RM_typeII) * this.stepSizeSec * this.enzymeBounds(this.reactionIndexs_RM_MunI_Restriction, 2))])));
            if numReactions == 0
                return;
            end
            
            [~, ~, posStrnds, numReactions] = this.bindProteinToChromosome(...
                posStrnds, this.enzymeIndexs_RM_typeII, numReactions, [], false, true, 1, false, -1:1);
            if numReactions == 0
                return;
            end
            
            c.strandBreaks(posStrnds) = 1;
            
            this.substrates = this.substrates + ...
                numReactions * this.reactionSmallMoleculeStoichiometryMatrix(:, this.reactionIndexs_RM_MunI_Restriction);
        end
    end
end